package idmapi

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"regexp"
	"strings"
	"time"

	log "github.com/sirupsen/logrus"

	"github.com/ForgeCloud/saas/tree/master/services/go/common/pkg/httputil"
	"github.com/ForgeCloud/saas/tree/master/services/go/common/pkg/models/user"
	"github.com/sethgrid/pester"
)

const APP_USER = "user"
const TEAM_MEMBER = "teammember"
const ALL_FIELDS_PATH = "/managed/%s/%s?_fields=*,_meta/*"

const (
	userNameHeaderName = "X-OpenIDM-Username"
	passwordHeaderName = "X-OpenIDM-Password"

	requestedWithHeaderName  = "X-Requested-With"
	requestedWithHeaderValue = "forgecloud_org-api"

	contentTypeHeaderName      = "Content-Type"
	contentTypeHeaderJSONValue = "application/json"
)

var (
	// baseURLRegexp matches lower-case HTTP URLs with host:port and optional prefix-path
	baseURLRegexp = regexp.MustCompile("^https?://[a-z][a-z0-9-_.]*:[0-9]+(?:/[a-z0-9-_]+)*$")

	// adminAuthzRoles give a Managed User full admin access to IDM
	adminAuthzRoles = []RoleItem{{openIDMAdminRoleRef}, {openIDMAuthorizedRoleRef}}
)

// Client for making authenticated REST calls to IDM, which is inside the organization project.
type Client struct {
	// Pester client is thread-safe, but be aware of https://github.com/sethgrid/pester/issues/19
	client      httputil.HTTPClienter
	idmUserName string
	idmPassword string
	idmBaseURL  string
}

// NewClient initializes the Client, for making authenticated REST calls to the saas project.
func NewClient(
	idmBaseURL string,
	idmUserName string,
	idmPassword string,
	timeout time.Duration,
) (*Client, error) {

	pest := pester.New()
	pest.KeepLog = true
	pest.Concurrency = 1
	pest.MaxRetries = 5
	pest.Backoff = pester.LinearBackoff
	pest.Timeout = timeout

	return NewClientWithHTTPClienter(idmBaseURL, idmUserName, idmPassword, pest)
}

// NewClientWithHTTPClienter initializes the Client, for making authenticated REST calls to IDM,
// with a specific HTTP client (useful for testing).
func NewClientWithHTTPClienter(idmBaseURL string, idmUserName string, idmPassword string, httpClient httputil.HTTPClienter) (*Client, error) {
	if len(strings.TrimSpace(idmUserName)) == 0 || len(strings.TrimSpace(idmPassword)) == 0 {
		return nil, ErrUserNameAndPasswordRequired
	}
	if !baseURLRegexp.MatchString(idmBaseURL) {
		return nil, ErrIDMBaseURLInvalid
	}
	return &Client{
		client:      httpClient,
		idmUserName: idmUserName,
		idmPassword: idmPassword,
		idmBaseURL:  idmBaseURL,
	}, nil
}

// CreateTeamMember will create an IDM Managed User record with administrative priviledges.
// The email, and password arguments are required. The ID generated by IDM is returned.
//
// This function only manages user profile data that needs to stay in sync with org-api and saas-api.
func (c *Client) CreateTeamMember(email string, password string, firstName string, lastName string) (id string, err error) {
	if len(email) == 0 {
		return "", ErrEmailRequired
	}
	if len(password) == 0 {
		return "", ErrPasswordRequired
	}
	requestBody := &CreateRequestBody{
		UserName:   email,
		Email:      email,
		Password:   password,
		FirstName:  firstName,
		LastName:   lastName,
		AuthzRoles: adminAuthzRoles,
	}
	resp, err := c.doRequest("/managed/teammember?_action=create", "POST", requestBody)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()
	if resp.StatusCode >= 400 {
		return "", errorFromResponse(resp)
	}
	responseBody := &CreateResponseBody{}
	if err := json.NewDecoder(resp.Body).Decode(responseBody); err != nil {
		return "", err
	}
	if len(responseBody.ID) == 0 {
		return "", ErrUnexpectedIDMResponse
	}
	return responseBody.ID, nil
}

func (c *Client) GetTeamMember(id string) (*user.User, error) {
	return c.getManagedUser(id, TEAM_MEMBER)
}

func (c *Client) GetAppUser(id string) (*user.User, error) {
	return c.getManagedUser(id, APP_USER)
}

func (c *Client) getManagedUser(id string, userType string) (*user.User, error) {
	if "" == id {
		return nil, fmt.Errorf("id is required")
	}
	if "" == userType {
		return nil, fmt.Errorf("userType is required")
	}
	switch userType {
	case TEAM_MEMBER, APP_USER:
		break
	default:
		return nil, ErrUserTypeUnknown
	}
	path := fmt.Sprintf(ALL_FIELDS_PATH, userType, id)
	resp, err := c.doRequest(path, "GET", nil)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	var user user.User
	err = json.NewDecoder(resp.Body).Decode(&user)
	if err != nil {
		return nil, err
	}
	return &user, errorFromResponse(resp)
}

// UpdateTeamMember will update an IDM Managed User record with administrative priviledges.
// The IDM Managed User id argument is required, but other string arguments will be ignored if they are blank.
//
// This function only manages user profile data that needs to stay in sync with org-api and saas-api.
func (c *Client) UpdateTeamMember(id string, email string, password string, firstName string, lastName string) error {
	if len(id) == 0 {
		return ErrIDRequired
	}
	var requestBody PatchRequestBody

	if len(email) != 0 {
		requestBody = appendPatchReplaceOperation(requestBody, patchEmailField, email)
	}
	if len(password) != 0 {
		requestBody = appendPatchReplaceOperation(requestBody, patchPasswordField, password)
	}
	if len(firstName) != 0 {
		requestBody = appendPatchReplaceOperation(requestBody, patchFirstNameField, firstName)
	}
	if len(lastName) != 0 {
		requestBody = appendPatchReplaceOperation(requestBody, patchLastNameField, lastName)
	}

	if len(requestBody) == 0 {
		// nothing to patch
		return nil
	}
	resp, err := c.doRequest("/managed/teammember/"+id, "PATCH", requestBody)
	if err != nil {
		return err
	}
	defer resp.Body.Close()
	return errorFromResponse(resp)
}

func appendPatchReplaceOperation(requestBody PatchRequestBody, field string, value string) PatchRequestBody {
	return append(requestBody, PatchOperation{
		Operation: patchReplaceOperation,
		Field:     field,
		Value:     value,
	})
}

// DeleteTeamMember will delete an IDM Managed User record. The IDM Managed User id argument is required.
func (c *Client) DeleteTeamMember(id string) error {
	if len(id) == 0 {
		return ErrIDRequired
	}
	resp, err := c.doRequest("/managed/teammember/"+id, "DELETE", nil)
	if err != nil {
		return err
	}
	defer resp.Body.Close()
	return errorFromResponse(resp)
}

func (c *Client) doRequest(urlPath string, httpMethod string, requestBody interface{}) (resp *http.Response, err error) {
	if len(urlPath) == 0 {
		return nil, ErrURLPathRequired
	}
	url := c.idmBaseURL + urlPath

	var bodyReader io.Reader
	if requestBody != nil {
		requestBytes, err := json.Marshal(requestBody)
		if err != nil {
			return nil, err
		}
		bodyReader = bytes.NewReader(requestBytes)
	}

	req, err := http.NewRequest(httpMethod, url, bodyReader)
	if err != nil {
		return nil, err
	}
	req.Header.Set(userNameHeaderName, c.idmUserName)
	req.Header.Set(passwordHeaderName, c.idmPassword)
	req.Header.Set(requestedWithHeaderName, requestedWithHeaderValue)
	if requestBody != nil {
		req.Header.Set(contentTypeHeaderName, contentTypeHeaderJSONValue)
	}
	return c.client.Do(req)
}

// errorFromResponse maps HTTP status codes to predefined errors, logs JSON error responses from IDM,
// and returns nil for non-error HTTP status codes.
func errorFromResponse(resp *http.Response) error {
	if resp.StatusCode >= 400 {
		buf := new(bytes.Buffer)
		if _, err := buf.ReadFrom(resp.Body); err != nil {
			return fmt.Errorf("could not readFrom with error: %s", err.Error())
		}
		log.Warnf("IDM response: %v", buf.String())
		switch resp.StatusCode {
		case http.StatusNotFound:
			return ErrTeamMemberNotFound
		case http.StatusUnauthorized:
			return ErrIDMAuthenticationFailed
		case http.StatusPreconditionFailed:
			return ErrTeamMemberAlreadyExists
		default:
			return fmt.Errorf(StatusCodeErrorTemplate, resp.StatusCode)
		}
	}
	return nil
}
