package messaging

import (
	"context"
	"math"
	"strconv"
	"time"

	"cloud.google.com/go/pubsub"
	"github.com/pkg/errors"
	"github.com/sirupsen/logrus"
)

// AttrKey is a type used for known keys of the message.Attribute map.
type AttrKey string

const (
	// AttrNextAttemptUTC is the next scheduled message processing attempt for a message.
	AttrNextAttemptUTC AttrKey = "nextAttemptUTC"
	// AttrAttempts is the number of times a message has attempted to be processed
	AttrAttempts AttrKey = "attempts"
	// AttrTopicID is the topic id a given message is being processed from
	AttrTopicID AttrKey = "TopicID"
	// AttrSubscriptionID is the subscription id of the subscription a message is being processed from
	AttrSubscriptionID AttrKey = "SubscriptionID"
	// AttrError is the .Error() text of the last error to occur when processing this message
	AttrError AttrKey = "Error"
	// AttrOriginalID is the ID generated by the server when the message was originally published
	// this is tracked due to the ID changing when the message is "re-published" due a failure.
	AttrOriginalID AttrKey = "IDOrig"
)

// FailureRetryBackOff is a backoff strategy for messaging with pubsub that will schedule retries
// with a decreasing frequency until the max retries is met.
//
// It is advised to set the subscription's ReceiveSettings.MaxExtension to more than greater than the
// value of the MaxDelay config parameter to avoid duplicate messages.
type FailureRetryBackOff struct {
	// log: a logger to use for any logging related to the strategy.
	log *logrus.Entry
	// maxAttempts: see FailureRetryBackOffConfig
	maxAttempts int
	// deadLetterPublisher: see FailureRetryBackOffConfig
	deadLetterPublisher PublisherServicer
	// rePublisher: see FailureRetryBackOffConfig
	rePublisher PublisherServicer
	// backOffDelayRatio: see FailureRetryBackOffConfig
	backOffDelayRatio float64
	// backOffDelatInit: see FailureRetryBackOffConfig
	backOffDelayInit time.Duration
	// maxSleep: see FailureRetryBackOffConfig
	maxSleep time.Duration
	// maxDelay: see FailureRetryBackOffConfig
	maxDelay time.Duration
	// msgService: The service to use for various message operations & transformations
	// i.e. Use this for Acking or Nacking a message.
	msgService MessageServicer
}

//FailureRetryBackOffConfig: config for the failure strategy `FailureRetryBackOff`
type FailureRetryBackOffConfig struct {
	// MaxAttempts is the maximum number of attempts allowed for any given message before giving up.
	// 0 -> take the default
	// negative -> disabled
	// positive -> actual max attempts
	MaxAttempts int
	// DeadLetterPublisher is used to publish a message that has failed to process for MaxAttempts attempts.
	DeadLetterPublisher PublisherServicer
	// RePublisher is used to republish the message with the updated Attributes for a successive processing attempt.
	RePublisher PublisherServicer
	// BackOffDelayRatio: the ratio to increase the retry backoff duration.
	// i.e. if backOffDelayRatio is set to 2, the amount of time between successive attempts will be doubled for each attempt
	BackOffDelayRatio float64
	// BackOffDelayInit is the initial delay duration
	BackOffDelayInit time.Duration
	// MaxSleep: the upper limit to how long a given handler should sleep while waiting for the message to be ready
	//           this ensures that a single message will not consume any given handler goroutine for too long.
	MaxSleep time.Duration
	// MaxDelay is the max duration to delay between attempts.
	// e.g. so even if the result of maxAttempts, backOffDelayInit and backOffDelayRatio would
	//      result in an eventual very large delay if unconstrained, the delay between attempts
	//      will stop increasing at this maxDelay
	//
	// WARN: This should be set to much less than the subscription's ReceiveSettings.MaxExtension parameter
	//       to avoid message duplication.
	MaxDelay time.Duration
}

// FailureRetryBackOffConfigDefaults provides some sensible default values for
// certain FailureRetryBackOffConfig attributes when they're not set.
var FailureRetryBackOffConfigDefaults = FailureRetryBackOffConfig{
	MaxAttempts:       20,
	BackOffDelayRatio: 2,
	BackOffDelayInit:  5 * time.Second,
	MaxSleep:          1 * time.Minute,
	MaxDelay:          10 * time.Minute,
}

func NewFailureRetryBackOff(c FailureRetryBackOffConfig) (*FailureRetryBackOff, error) {

	/// Set Defaults
	if c.MaxAttempts == 0 {
		c.MaxAttempts = FailureRetryBackOffConfigDefaults.MaxAttempts
	}
	if c.BackOffDelayRatio == 0 {
		c.BackOffDelayRatio = FailureRetryBackOffConfigDefaults.BackOffDelayRatio
	}
	if c.BackOffDelayInit == 0 {
		c.BackOffDelayInit = FailureRetryBackOffConfigDefaults.BackOffDelayInit
	}
	if c.MaxSleep == 0 {
		c.MaxSleep = FailureRetryBackOffConfigDefaults.MaxSleep
	}
	if c.MaxDelay == 0 {
		c.MaxDelay = FailureRetryBackOffConfigDefaults.MaxDelay
	}

	// Validate some config options
	if c.RePublisher == nil {
		return nil, errors.New("RePublisher must be set to an initialized PublishingServicer")
	}

	return &FailureRetryBackOff{
		log: logrus.WithFields(logrus.Fields{
			"pkg": "messaging/v2",
			"svc": "FailureRetryBackOff",
		}),
		maxAttempts:         c.MaxAttempts,
		deadLetterPublisher: c.DeadLetterPublisher,
		rePublisher:         c.RePublisher,
		backOffDelayInit:    c.BackOffDelayInit,
		backOffDelayRatio:   c.BackOffDelayRatio,
		maxSleep:            c.MaxSleep,
		maxDelay:            c.MaxDelay,
		msgService:          &MessageService{},
	}, nil
}

// WrapHandler in this case deals with the delay and attempt tracking
func (f FailureRetryBackOff) WrapHandler(h WrappedMessageHandlerFunc, trackingAttributes map[AttrKey]string) MessageHandlerFunc {
	return func(ctx context.Context, msg *pubsub.Message) {

		if f.sleepUntilNextAttempt(msg) == errNotReadyForNextAttempt {
			f.msgService.Nack(msg)
			return
		}

		// Increment the number of attempts
		msg = f.incrementAttempts(msg)

		// Insert additional tracking attributes - iterating over nil map is fine in go
		// if trackingAttributes != nil {
		for k, v := range trackingAttributes {
			msg.Attributes[string(k)] = v
		}
		//}

		// Let's track the original message id so we can keep track of where it is.
		if msg.Attributes[string(AttrOriginalID)] == "" {
			msg.Attributes[string(AttrOriginalID)] = msg.ID
		}

		// Handle the message
		if err := h(ctx, msg); err != nil {
			f.handleFailure(msg, err)
			return
		}
		f.msgService.Ack(msg)
	}
}

func (f FailureRetryBackOff) handleFailure(msg *pubsub.Message, err error) {

	ctx := context.Background()
	msg = f.updateNextAttemptUTC(msg)
	log := f.log.WithFields(logrus.Fields{
		"func":   "handleFailure",
		"ID":     msg.ID,
		"IDOrig": msg.Attributes[string(AttrOriginalID)],
	})

	// if we're out of attempts, send to dead letter queue (if configured) and ack it.
	if f.maxAttempts > 0 && f.attempts(msg) >= f.maxAttempts {
		log.Info("Out of attempts")
		if f.deadLetterPublisher != nil {
			msg.Attributes[string(AttrError)] = err.Error()
			if _, err := f.deadLetterPublisher.Publish(ctx, msg); err != nil {
				log.Errorf("could not publish to DeadLetterPublisher %v", err)
			}
		}
		f.msgService.Ack(msg)
		return
	}

	// If no rePublisher is defined, let the message redelivery be handled as default.
	// This means: the pubsub service will release the message for redelivery when
	//             the subscription's ackDeadline + MaxExtension is achieved.
	delayMsg := "Message retry will be delayed for a duration up to the subscription's AckDeadline + MaxExtension."
	if f.rePublisher == nil {
		log.Warn("RePublisher not initialized. " + delayMsg)
		return
	}

	if _, err := f.rePublisher.Publish(ctx, msg); err != nil {
		log.Error("Failed to republish the message. " + delayMsg)
		return
	}
	// WARN: if for some reason it dies between a successful publish and the ack, duplicate messages will result
	f.msgService.Ack(msg)
}

var ErrBackOffDurationAckDeadlineMismatch = errors.New(
	"the maximum back-off duration must be less than " +
		"one minute less than the subscription's AckDeadline + MaxAckExtension")

func (f FailureRetryBackOff) ValidateForSubscriptionConfig(cfg SubscriptionServiceConfig) error {
	/// Need to make sure that pubsub won't re-deliver the message while doing retry-back-off
	//
	// re-publishing means that the ack duration MUST NOT exceed the MaxAckDeadline (or AckDeadline if MaxAckDeadline is 0)
	// or it will result in duplicate messages existing in the subscription

	// Our max deadline
	maxDelayDuration := f.delayDuration(f.maxAttempts)
	maxDelayBuffer := 10 * time.Second // allows additional processing time between our deadline and pubsub's deadline.

	// Determine actual pubsub ackDeadline
	// this replicates logic in pubsub library for determining actual Ack Deadline.
	ackDeadline := cfg.Options.AckDeadline
	switch maxExt := cfg.Options.ReceiveSettings.MaxExtension; {
	case maxExt > 0:
		ackDeadline = ackDeadline + maxExt
	case maxExt == 0:
		ackDeadline = ackDeadline + DefaultReceiveSettings.MaxExtension
	}

	// Ideally maxDelayDuration will be less than ackDeadline combined with the time it takes to process the messages successfully.
	if ackDeadline <= maxDelayDuration+maxDelayBuffer {
		f.log.WithFields(logrus.Fields{
			"ackDeadline":      ackDeadline.String(),
			"maxDelayDuration": maxDelayDuration.String(),
		}).Error("ackDeadline less than maxDelayDuration")
		return ErrBackOffDurationAckDeadlineMismatch
	}
	return nil
}

var errNotReadyForNextAttempt = errors.New("not ready for next attempt")

// sleepUntilNextAttempt will issue a time.Sleep for a duration up f.MaxSleep
// If it is still not time to process the message, return errNotReadyForNextAttempt.
func (f FailureRetryBackOff) sleepUntilNextAttempt(msg *pubsub.Message) error {
	//log := f.log.WithFields(logrus.Fields{
	//	"func": "handleFailure",
	//	"ID":   msg.ID,
	//})
	now := time.Now().UTC()

	nextUTC, err := f.nextAttemptUTC(msg)
	if err != nil {
		nextUTC = now
	}

	// Not time to process this message.
	if nextUTC.After(now) {
		durationUntilNext := nextUTC.Sub(now)

		// Sleep as much as possible, then indicate not ready.
		if durationUntilNext > f.maxSleep {
			time.Sleep(f.maxSleep)
			return errNotReadyForNextAttempt
		}

		// Sleep until ready for the next attempt
		time.Sleep(durationUntilNext)
	}
	return nil
}

// delayDuration calculates the duration that should be delayed between the given attempt and the following attempt.
func (f FailureRetryBackOff) delayDuration(attempt int) time.Duration {
	backOffRatio := math.Pow(f.backOffDelayRatio, float64(attempt-1))
	// try to avoid Uint64 overrun (confusing issues)
	if math.IsInf(backOffRatio, 1) || backOffRatio > math.MaxUint32 {
		return f.maxDelay
	}
	delayDuration := time.Duration(backOffRatio) * f.backOffDelayInit

	if delayDuration <= 0 {
		return f.maxDelay
	}

	if delayDuration > f.maxDelay {
		delayDuration = f.maxDelay
	}
	return delayDuration
}

// updateNextAttemptUTC will return a modified copy of the message with the next attempt time updated.
func (f FailureRetryBackOff) updateNextAttemptUTC(msg *pubsub.Message) *pubsub.Message {
	newMsg := *msg

	priorAttemptUTC, err := f.nextAttemptUTC(&newMsg)
	if err != nil {
		priorAttemptUTC = time.Now().UTC()
	}

	delayDuration := f.delayDuration(f.attempts(msg))
	nextUTC := priorAttemptUTC.Add(delayDuration)
	if newMsg.Attributes == nil {
		newMsg.Attributes = make(map[string]string)
	}
	newMsg.Attributes[string(AttrNextAttemptUTC)] = nextUTC.UTC().Format(time.RFC3339Nano)

	return &newMsg
}

// incrementAttempts will return a modified copy of the message with the attempt count incremented by one.
func (f FailureRetryBackOff) incrementAttempts(msg *pubsub.Message) *pubsub.Message {
	newMsg := f.ensureAttributes(msg)
	newMsg.Attributes[string(AttrAttempts)] = strconv.Itoa(f.attempts(msg) + 1)
	return newMsg
}

// attempts returns the attempt count stored on the given message.
func (f FailureRetryBackOff) attempts(msg *pubsub.Message) int {
	log := logrus.WithFields(logrus.Fields{
		"func": "attempts",
		"pkg":  "messaging",
		"svc":  "MessageService",
	})
	msg = f.ensureAttributes(msg)
	r := msg.Attributes[string(AttrAttempts)]
	if r == "" {
		r = "0"
	}
	attempts, err := strconv.Atoi(r)
	if err != nil {
		log.WithError(err).Errorf("msg attribute %q was not a valid int", AttrAttempts)
		attempts = 0
	}
	return attempts
}

var errNextScheduleAttemptMissing = errors.New("next scheduled attempt missing")
var errNextScheduledAttemptInvalid = errors.New("next scheduled attempt is invalid UTC string")

// nextAttemptUTC will return the Time of the next attempt in UTC if present on the message.
func (f FailureRetryBackOff) nextAttemptUTC(msg *pubsub.Message) (time.Time, error) {
	msg = f.ensureAttributes(msg)

	nextUTCString := msg.Attributes[string(AttrNextAttemptUTC)]
	if nextUTCString == "" {
		return time.Time{}, errNextScheduleAttemptMissing
	}

	nextUTC, err := time.Parse(time.RFC3339Nano, nextUTCString)
	if err != nil {
		return time.Time{}, errNextScheduledAttemptInvalid
	}

	return nextUTC, nil
}

// ensureAttributes will return a copy of the message with assurance that message.Attributes will be an initialized
// map[string]string. It will initialize it if nil, otherwise no change.
func (f FailureRetryBackOff) ensureAttributes(msg *pubsub.Message) *pubsub.Message {
	newMsg := *msg
	if newMsg.Attributes == nil {
		newMsg.Attributes = make(map[string]string)
	}
	return &newMsg
}
