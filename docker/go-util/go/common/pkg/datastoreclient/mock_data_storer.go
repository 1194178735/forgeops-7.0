// Code generated by mockery v1.0.0. DO NOT EDIT.
package datastoreclient

import context "context"
import datastore "cloud.google.com/go/datastore"
import mock "github.com/stretchr/testify/mock"

// MockDataStorer is an autogenerated mock type for the DataStorer type
type MockDataStorer struct {
	mock.Mock
}

// AllocateIDs provides a mock function with given fields: ctx, keys
func (_m *MockDataStorer) AllocateIDs(ctx context.Context, keys []*datastore.Key) ([]*datastore.Key, error) {
	ret := _m.Called(ctx, keys)

	var r0 []*datastore.Key
	if rf, ok := ret.Get(0).(func(context.Context, []*datastore.Key) []*datastore.Key); ok {
		r0 = rf(ctx, keys)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*datastore.Key)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, []*datastore.Key) error); ok {
		r1 = rf(ctx, keys)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Close provides a mock function with given fields:
func (_m *MockDataStorer) Close() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Count provides a mock function with given fields: ctx, q
func (_m *MockDataStorer) Count(ctx context.Context, q *datastore.Query) (int, error) {
	ret := _m.Called(ctx, q)

	var r0 int
	if rf, ok := ret.Get(0).(func(context.Context, *datastore.Query) int); ok {
		r0 = rf(ctx, q)
	} else {
		r0 = ret.Get(0).(int)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *datastore.Query) error); ok {
		r1 = rf(ctx, q)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Delete provides a mock function with given fields: ctx, key
func (_m *MockDataStorer) Delete(ctx context.Context, key *datastore.Key) error {
	ret := _m.Called(ctx, key)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *datastore.Key) error); ok {
		r0 = rf(ctx, key)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteMulti provides a mock function with given fields: ctx, keys
func (_m *MockDataStorer) DeleteMulti(ctx context.Context, keys []*datastore.Key) error {
	ret := _m.Called(ctx, keys)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []*datastore.Key) error); ok {
		r0 = rf(ctx, keys)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Get provides a mock function with given fields: ctx, key, dst
func (_m *MockDataStorer) Get(ctx context.Context, key *datastore.Key, dst interface{}) error {
	ret := _m.Called(ctx, key, dst)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *datastore.Key, interface{}) error); ok {
		r0 = rf(ctx, key, dst)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetAll provides a mock function with given fields: ctx, q, dst
func (_m *MockDataStorer) GetAll(ctx context.Context, q *datastore.Query, dst interface{}) ([]*datastore.Key, error) {
	ret := _m.Called(ctx, q, dst)

	var r0 []*datastore.Key
	if rf, ok := ret.Get(0).(func(context.Context, *datastore.Query, interface{}) []*datastore.Key); ok {
		r0 = rf(ctx, q, dst)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*datastore.Key)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *datastore.Query, interface{}) error); ok {
		r1 = rf(ctx, q, dst)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetMulti provides a mock function with given fields: ctx, keys, dst
func (_m *MockDataStorer) GetMulti(ctx context.Context, keys []*datastore.Key, dst interface{}) error {
	ret := _m.Called(ctx, keys, dst)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []*datastore.Key, interface{}) error); ok {
		r0 = rf(ctx, keys, dst)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Mutate provides a mock function with given fields: ctx, muts
func (_m *MockDataStorer) Mutate(ctx context.Context, muts ...*datastore.Mutation) ([]*datastore.Key, error) {
	_va := make([]interface{}, len(muts))
	for _i := range muts {
		_va[_i] = muts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 []*datastore.Key
	if rf, ok := ret.Get(0).(func(context.Context, ...*datastore.Mutation) []*datastore.Key); ok {
		r0 = rf(ctx, muts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*datastore.Key)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, ...*datastore.Mutation) error); ok {
		r1 = rf(ctx, muts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewTransaction provides a mock function with given fields: ctx, opts
func (_m *MockDataStorer) NewTransaction(ctx context.Context, opts ...datastore.TransactionOption) (DataStorerTransaction, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 DataStorerTransaction
	if rf, ok := ret.Get(0).(func(context.Context, ...datastore.TransactionOption) DataStorerTransaction); ok {
		r0 = rf(ctx, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(DataStorerTransaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, ...datastore.TransactionOption) error); ok {
		r1 = rf(ctx, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Put provides a mock function with given fields: ctx, key, src
func (_m *MockDataStorer) Put(ctx context.Context, key *datastore.Key, src interface{}) (*datastore.Key, error) {
	ret := _m.Called(ctx, key, src)

	var r0 *datastore.Key
	if rf, ok := ret.Get(0).(func(context.Context, *datastore.Key, interface{}) *datastore.Key); ok {
		r0 = rf(ctx, key, src)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*datastore.Key)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *datastore.Key, interface{}) error); ok {
		r1 = rf(ctx, key, src)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutMulti provides a mock function with given fields: ctx, keys, src
func (_m *MockDataStorer) PutMulti(ctx context.Context, keys []*datastore.Key, src interface{}) ([]*datastore.Key, error) {
	ret := _m.Called(ctx, keys, src)

	var r0 []*datastore.Key
	if rf, ok := ret.Get(0).(func(context.Context, []*datastore.Key, interface{}) []*datastore.Key); ok {
		r0 = rf(ctx, keys, src)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*datastore.Key)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, []*datastore.Key, interface{}) error); ok {
		r1 = rf(ctx, keys, src)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Run provides a mock function with given fields: ctx, q
func (_m *MockDataStorer) Run(ctx context.Context, q *datastore.Query) DataStorerIterator {
	ret := _m.Called(ctx, q)

	var r0 DataStorerIterator
	if rf, ok := ret.Get(0).(func(context.Context, *datastore.Query) DataStorerIterator); ok {
		r0 = rf(ctx, q)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(DataStorerIterator)
		}
	}

	return r0
}

// RunInTransaction provides a mock function with given fields: ctx, f, opts
func (_m *MockDataStorer) RunInTransaction(ctx context.Context, f func(DataStorerTransaction) error, opts ...datastore.TransactionOption) (*datastore.Commit, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, f)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *datastore.Commit
	if rf, ok := ret.Get(0).(func(context.Context, func(DataStorerTransaction) error, ...datastore.TransactionOption) *datastore.Commit); ok {
		r0 = rf(ctx, f, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*datastore.Commit)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, func(DataStorerTransaction) error, ...datastore.TransactionOption) error); ok {
		r1 = rf(ctx, f, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}
